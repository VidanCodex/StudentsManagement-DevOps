üéØ R√®gle Fondamentale du mappedBy :

       **     mappedBy se met toujours du c√¥t√© qui NE poss√®de PAS la cl√© √©trang√®re (Foreign Key)


üéì R√®gles pratiques pour le test
Relation bidirectionnelle @OneToMany / @ManyToOne :

‚úÖ Le c√¥t√© @ManyToOne (FILS) utilise @JoinColumn (poss√®de la FK)
‚úÖ Le c√¥t√© @OneToMany (PARENT) utilise mappedBy

Relation bidirectionnelle @ManyToMany :

‚úÖ Un seul c√¥t√© cr√©e la table de jointure (sans mappedBy)
‚úÖ L'autre c√¥t√© utilise mappedBy

Relation unidirectionnelle :

‚ùå PAS de mappedBy du tout !
Exemple : Si seulement Foyer conna√Æt Bloc (mais pas l'inverse), on ne met pas mappedBy








üìå Quand utiliser KEYWORDS ?
‚úÖ Utilisez les Keywords pour :
1Ô∏è‚É£ Recherches simples sur UN attribut
java// Trouver un √©tudiant par CIN
Etudiant findByCin(Long cin);

// Trouver un foyer par nom
Foyer findByNomFoyer(String nom);

// Trouver des blocs par capacit√©
List<Bloc> findByCapaciteBloc(Long capacite);
Pourquoi Keywords ?

‚úÖ Une seule ligne, pas besoin d'√©crire la requ√™te
‚úÖ Facile √† lire et comprendre
‚úÖ Spring fait tout automatiquement


2Ô∏è‚É£ Recherches avec 2-3 conditions simples (AND/OR)
java// Trouver un √©tudiant par nom ET pr√©nom
Etudiant findByNomEtAndPrenomEt(String nom, String prenom);

// Trouver des √©tudiants par √©cole OU nom
List<Etudiant> findByEcoleOrNomEt(String ecole, String nom);
Pourquoi Keywords ?

‚úÖ Conditions simples, pas de JOIN
‚úÖ Code court et clair


3Ô∏è‚É£ Comparaisons simples (>, <, BETWEEN, LIKE)
java// Capacit√© sup√©rieure √† X
List<Foyer> findByCapaciteFoyerGreaterThan(Long capacite);

// Nom qui contient X
List<Etudiant> findByNomEtContaining(String nom);

// Date entre deux dates
List<Reservation> findByAnneeUniversitaireBetween(Date debut, Date fin);
Pourquoi Keywords ?

‚úÖ Op√©rations standards d√©j√† support√©es
‚úÖ Pas besoin d'√©crire SQL/JPQL


üìå Quand utiliser JPQL ?
‚úÖ Utilisez JPQL pour :
1Ô∏è‚É£ Requ√™tes avec JOIN (naviguer entre entit√©s li√©es)
Exemple : Trouver tous les Foyers qui ont un Bloc nomm√© "Bloc A"
‚ùå Impossible avec Keywords (trop complexe)
‚úÖ Facile avec JPQL :
java@Query("SELECT f FROM Foyer f JOIN f.blocs b WHERE b.nomBloc = :nomBloc")
List<Foyer> findFoyersByBlocName(@Param("nomBloc") String nomBloc);

Autre exemple : Trouver tous les Blocs qui ont des Chambres de type TRIPLE
java@Query("SELECT DISTINCT b FROM Bloc b JOIN b.chambres c WHERE c.typeC = 'TRIPLE'")
List<Bloc> findBlocsWithTripleRooms();
Pourquoi JPQL ?

‚úÖ Vous devez naviguer √† travers plusieurs relations (Bloc ‚Üí Chambre)
‚úÖ Keywords ne peut pas g√©rer cette complexit√©


2Ô∏è‚É£ Agr√©gations (COUNT, SUM, AVG, MAX, MIN)
Exemple : Compter le nombre de Blocs dans un Foyer
‚ùå Keywords ne supporte pas COUNT directement
‚úÖ JPQL :
java@Query("SELECT COUNT(b) FROM Bloc b WHERE b.foyer.idFoyer = :idFoyer")
Long countBlocsByFoyer(@Param("idFoyer") Long idFoyer);